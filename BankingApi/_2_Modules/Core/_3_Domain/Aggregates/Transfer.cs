using BankingApi._2_Modules.Accounts._3_Domain.Enums;
using BankingApi._2_Modules.Transfers._3_Domain.Errors;
using BankingApi._4_BuildingBlocks;
using BankingApi._4_BuildingBlocks._1_Ports.Inbound;
using BankingApi._4_BuildingBlocks._3_Domain.Entities;
using BankingApi._4_BuildingBlocks._4_Infrastructure;
namespace BankingApi.Modules.Core.Domain.Aggregates;

public sealed class Transfer : AggregateRoot<Guid> {
   private readonly List<Transaction> _transactions = new();

   // Aggregate references (IDs only, no navigation properties)
   public Guid FromAccountId { get; private set; }
   public Guid ToAccountId { get; private set; }

   // Business data
   public decimal Amount { get; private set; }
   public string Purpose { get; private set; } = string.Empty;

   // Snapshots for historical consistency (e.g. if beneficiaries are deleted)
   public string RecipientName { get; private set; } = string.Empty; // = beneficiary name at time of transfer
   public string RecipientIban { get; private set; } = string.Empty; // = beneficiary IBAN at time of transfer

   // Idempotency (generated by client)
   public string IdempotencyKey { get; private set; } = string.Empty;

   // State
   public TransferStatus Status { get; private set; }
   public DateTimeOffset BookedAt { get; private set; } = default!;

   // Child entities
   public IReadOnlyList<Transaction> Transactions => _transactions;

   //--- Ctor's ----------------------------------------------------------
   // EF Core ctor
   private Transfer() : base(new BankingSystemClock()) { }

   // Domain ctor 
   private Transfer(
      IClock clock,
      Guid id,
      Guid fromAccountId,
      Guid toAccountId,
      decimal amount,
      string purpose,
      string recipientName, // beneficiary name at time of transfer
      string recipientIban, // beneficiary IBAN at time of transfer
      string idempotencyKey,
      TransferStatus status
   ) : base(clock) {
      Id = id;
      FromAccountId = fromAccountId;
      ToAccountId = toAccountId;
      Amount = amount;
      Purpose = purpose;
      RecipientName = recipientName;
      RecipientIban = recipientIban;
      IdempotencyKey = idempotencyKey;
      Status = status;
   }

   //--- Factory method to create a new Transfer -------------------------
   public static Result<Transfer> Create(
      IClock clock,
      Guid fromAccountId,
      Guid toAccountId,
      decimal amount,
      string purpose,
      string recipientName,
      string recipientIban,
      string idempotencyKey,
      string? id
   ) {
      // trim early
      purpose = purpose?.Trim() ?? string.Empty;
      recipientName = recipientName.Trim();
      recipientIban = recipientIban.Trim();
      idempotencyKey = idempotencyKey.Trim();

      if (fromAccountId == toAccountId)
         return Result<Transfer>.Failure(TransferErrors.SameAccountNotAllowed);

      if (amount <= 0m)
         return Result<Transfer>.Failure(TransferErrors.AmountMustBePositive);

      if (string.IsNullOrWhiteSpace(recipientIban))
         return Result<Transfer>.Failure(TransferErrors.RecipientIbanRequired);
      if (string.IsNullOrWhiteSpace(idempotencyKey))
         return Result<Transfer>.Failure(TransferErrors.IdempotencyKeyRequired);

      var idResult = EntityId.Resolve(id, TransferErrors.InvalidId);
      if (idResult.IsFailure)
         return Result<Transfer>.Failure(idResult.Error);
      var transferId = idResult.Value;

      var transfer = new Transfer(
         clock: clock,
         id: transferId,
         fromAccountId: fromAccountId,
         toAccountId: toAccountId,
         amount: amount,
         purpose: purpose,
         recipientName: recipientName,
         recipientIban: recipientIban,
         idempotencyKey: idempotencyKey,
         status: TransferStatus.Initiated
         // UpdatedAt are set in SaveChanges
      );

      return Result<Transfer>.Success(transfer);
   }

   // Books the transfer and creates exactly two transactions
   public Result Book() {
      if (Status != TransferStatus.Initiated)
         return Result.Failure(TransferErrors.OnlyInitiatedCanBeBooked);

      // local invariant: transactions should be empty before booking
      _transactions.Clear();

      // create debit and credit transactions
      BookedAt = _clock.UtcNow;
      var transactionDebit = Transaction.CreateDebit(FromAccountId, Amount, Purpose, BookedAt);
      var transactionCredit = Transaction.CreateCredit(ToAccountId, Amount, Purpose, BookedAt);
      _transactions.Add(transactionDebit);
      _transactions.Add(transactionCredit);
      
      // update status
      Status = TransferStatus.Booked;
      Touch(); // updates UpdatedAt
      return Result.Success();
   }
}